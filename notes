Question

Features to build.
Dont implement logic yet.
Just write interfaces and code it up later. I know enough infrastructure to do this.

Coding Marathon:
Fix:
Test 1:
1. Primary Completes the (dummy) transaction but secondary is aware.
11. TxResult for TxOpRequest to be built


2. Secondary can recover the transaction but transaction is still dummy.
 (FINISH TESTING HERE)

3. Rewire recieve and response from a client.
3. Transaction Actually does something.
4. Abort and rollback the transaction.


1. Fill up with Document after each level.


######################## WAIT ###########################
d. How would responses be recieved by clients
e. Rebuild Secondary to take over primary with co-ordination.
a. Transaction ID is being repeated.(fixed)
b. Responses are messy, create a single packet interface(done)


1. The transaction should be sent and received at the entry server.
2. The entry server pushes it into the transaction module after co-ordination.
3. Sends a reply of Ok to the Replica initiating the request.
4. Fix Packet ID key architecture
5. Fix Packet type Response architecture
6. Write Code for Secondary
7. Write atleast one test


#### Later priorities
1. Create new packet types to handle message responses for client


a.  Completely understand ProtocolExecutor ??
ProtocolPacket

ProtocolTask
MessageTask

b.  How are Messaging Tasks handled ??
c.  How are messages to services sent and received
NIOMessenger -> Packet Demultiplexer(to receive Messsages) and NodeConfig(to get address)
ProtocolExecuter(Takes in NIOMesseger to send)
and all received messages are to be handed off via handleMessage

c. Where does the protocol executor wait for messages ??
At handleMessage
On recieve can either spawn another protocolTask or stay if it is not removed or respond with messages



Objective 1:

The primary cleanly executes the transaction without aborting.
This goes through all the 3 phases of lock, execute and abort.

Talk to arun about flexible replication